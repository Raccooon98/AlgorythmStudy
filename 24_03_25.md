<h1 align = "center">백준 14889번 스타트와 링크</h1>

### [문제 링크](https://www.acmicpc.net/problem/14889 "14889번 스타트와 링크")
---

### 최초 코드

```cpp
//백트래킹? DFS로 N개중 N/2개를 뽑는 조합이다 라고 생각을 하고 팀을 구한 후 두 팀의 능력치 차이의 최솟값을 계속 저장하면 될것 같다.

#include<iostream>
#include<algorithm>
#include<cmath>
#include<vector>
#define MAX 21
using namespace std;

bool team[MAX];
int stats[MAX][MAX];
int N;
int Min = 10000000;

//함수가 호출될때마다 새로운 요소들이 생성되게 하도록 함수안에 선언
//vector<int> start, link;
//int start_score, link_score;

void maketeam(int idx, int num) {
	vector<int> start, link;
	int start_score = 0; int link_score = 0;
	
	if (num == (N / 2)) {
		for (auto i = 0; i < N; ++i) {
			if (team[i] == 1)
				start.push_back(i);//조합으로 뽑은 팀 
			else
				link.push_back(i);//나머지 남는 사람들 팀
		}

		for (auto i = 0; i < N/2; ++i) {
			for (auto j = 0; j < N/2; ++j) {
				start_score += stats[start[i]][start[j]];
				link_score += stats[link[i]][link[j]];
			}
		}
		Min = min(Min,abs(start_score - link_score));
		return;
	}

	for (auto i = idx; i < N; ++i) {
		if (team[i])continue;
		else {
			team[i] = 1;
			maketeam(i, num + 1);
			team[i] = 0;
		}
	}
}

int main(void) {
	cin.tie(NULL)->sync_with_stdio(false);

	cin >> N;
	for (auto i = 0; i < N; ++i) {
		for (auto j = 0; j < N; ++j) {
			cin >> stats[i][j];
		}
	}

	maketeam(0, 0);
	cout << Min;
	return 0;
}
```

### 복기
이 문제는 N명의 선수중 절반은 스타트팀 절반은 링크팀으로 가는 것이라 순서 상관없이 조합으로 N개 중 N/2개를 선택하는 경우를 봤고 뽑아온 팀과 안뽑아온 팀의 스탯을 더해 비교한 후 최소값을 구하는 방식으로 진행했다. 피드백에서 알려주신 algorithm 헤더의 min 을 사용하여 코드의 길이를 더 줄였다.

<h1 align = "center">백준 14500번 테트로미노</h1>

### [문제 링크](https://www.acmicpc.net/problem/14500 "14500번 테트로미노")
---

### 최초 코드

```cpp
//테트로미노를 하나하나 놓아보고 판단한다... -> DFS? 백트래킹?
//블록들 모양이 T자 블록 빼고 나머지는 DFS로 탐색이 가능한 모양인데..
//T자블록만 따로 탐색을 구현하고 나머지는 DFS로 해결하면 될것 같은 문제 -> 생각보다는 어려움
//T자 블록은 세방향만 탐색하면 되는데 그렇게 하려면 직접 세방향을 보는 것을 네번 반복해야 하므로 네방향중 제일 작은 값을 버리는 방법을 사용.
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int N, M, result = 0;
int Map[501][501];
int vis[501][501];

int dx[] = { 1,0,-1,0 };
int dy[] = { 0,1,0,-1 };

void DFS(int x, int y, int num, int sum) {
	if (num == 4) {
		result = max(result, sum);
	}
	else {
		for (auto i = 0; i < 4; ++i) {
			int nx = x + dx[i];
			int ny = y + dy[i];
			if (nx < 0 || nx >= N || ny < 0 || ny >= M)continue;
			if (vis[nx][ny])continue;
			vis[nx][ny]++;
			DFS(nx, ny, num + 1, sum + Map[nx][ny]);
			vis[nx][ny]--;
		}
	}
}

int main(void) {
	cin.tie(NULL)->sync_with_stdio(false);
	cin >> N >> M;
	for (auto i = 0; i < N; ++i)
		for (auto j = 0; j < M; ++j)
			cin >> Map[i][j];

	for (auto i = 0; i < N; ++i) {
		for (auto j = 0; j < M; ++j) {
			vis[i][j]++;
			DFS(i, j, 1, Map[i][j]);
			vis[i][j]--;
		}
	}

	//T형 블록은 가운데를 중심으로 세 방향을 탐색 - > 네방향중에 제일 작은값을 버리고 나머지 세개랑 가운데만 더하기
	for (auto i = 0; i < N; ++i) {
		for (auto j = 0; j < M; ++j) {
			int tmp = Map[i][j];//T자블록 가운데
			int tmpMin = 1000000;

			for (auto dir = 0; dir < 4; ++dir) {
				tmpMin = min(Map[i + dx[dir]][j + dy[dir]],tmpMin);
				tmp += Map[i + dx[dir]][j + dy[dir]];
			}
			result = max(result, tmp - tmpMin);
		}
	}
	cout << result;
	return 0;
}
```

### 복기
이 문제를 풀면서 디버그 사용법을 배운것이 천만 다행이라고 생각했다. 컴파일을 해 TC를 넣었는데 값이 조금씩 크게 나오길래 디버그를 해봤더니 DFS를 4번이 아닌 5번까지 도는 경우가 생기는것 이었다. 그래서 3번쯤 디버그를 해봤는데
```cpp
for (auto i = 0; i < N; ++i) {
		for (auto j = 0; j < M; ++j) {
			vis[i][j]++;
			DFS(i, j, 1, Map[i][j]);
			vis[i][j]--;
		}
	}
```
DFS를 호출해야하는 부분에서 최초에는 3번째 인자에 몇번 반복인지 카운트해주는 숫자를 1로 넣어서 4번만 탐색하게끔 했어야했는데 
DFS(i, j, i, Map[i][j]);
i를 넣어서 0이 들어가는 경우가 생겼었다. 그 결과 탐색을 5번까지 하는 경우가 생겼고 이것을 수정하니 답이 나왔다.

블록들의 모양이 T자 말고는 DFS로 탐색이 가능한 모양들이라서 DFS로 4번 돌릴 수 있을만큼 돌려 최대값을 저장하고, T자 블록은 가운데를 시작점으로 잡아 4방향을 탐색한 뒤 제일 작은 점을 제외하는 방식으로 최대값을 저장한 뒤 둘을 비교해 답을 찾았다.

<h1 align = "center">백준 번 </h1>

### [문제 링크](https://www.acmicpc.net/problem/ "")
---

### 최초 코드

```cpp

```

### 복기

### 최종 코드
```cpp

```