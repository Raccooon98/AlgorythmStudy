<h1 align = "center">백준 15663번 N과M(9) </h1>

### [문제 링크](https://www.acmicpc.net/problem/15663 "15663번 N과M(9)")
---

### 최초 코드
```cpp

```
### 복기
이 문제는 새로운 형식이라 좀 당황했다.. arr[k]를 출력하고 0으로 초기화해주는 작업이 필요했다(벡터였으면 pop_back으로 간단하게 하면 됐을것같다.)
### 최종 코드
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int N, M;
//vector<int> arr; // 값이 없을때 비교가 안되고 out of range나와서 일단 배열로 구현
int arr[9] = { 0, };
vector<int> input;
bool isused[9] = { 0, };

void dfs(int k) {
	if (k == M) {
		for (auto i = 0; i < M; ++i) {
			cout << arr[i] << " ";
		}
		cout << "\n";
		arr[k] = 0;
		return;
	}

	for (auto i = 1; i <= N; ++i) {
		if (!isused[i]) {
			if (arr[k] != input[i]) {
				if (k == 0)arr[k] = input[i];
				else if (arr[k - 1] <= input[i])arr[k] = input[i];
				else continue
			}

			else continue;
			isused[i] = 1;
			dfs(k + 1);
			isused[i] = 0;
		}
	}
	arr[k] = 0;
}

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);

	cin >> N >> M;
	input.push_back(0);

	for (auto i = 0; i < N; ++i) {
		int a;
		cin >> a;
		input.push_back(a);
	}

	sort(input.begin(), input.end());
	dfs(0);

	return 0;
}
```

<h1 align = "center">백준 15664번 N과M(10) </h1>

### [문제 링크](https://www.acmicpc.net/problem/15664 "15664번 N과M(10)")
---

### 최초 코드
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int n, m;
vector<int> v;
int arr[9] = { 0 };
bool isused[9] = { 0 };

void func(int k) {
	if (k == m) {
		for (int i = 0; i < m; i++) {
			cout << arr[i] << " ";
		}
		cout << "\n";

		arr[k] = 0;
		return;
	}

	for (int i = 1; i <= n; i++) {
		if (!isused[i]) {
			if (arr[k] != v[i]) {
				if (k == 0) arr[k] = v[i];
				else if (arr[k - 1] <= v[i]) arr[k] = v[i];
				else continue;
			}
			else continue;

			isused[i] = 1;

			func(k + 1);

			isused[i] = 0;
		}
	}

	arr[k] = 0;
}

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> m;

	v.push_back(0);

	for (int i = 0; i < n; i++) {
		int a;

		cin >> a;

		v.push_back(a);
	}

	sort(v.begin(), v.end());

	func(0);

	return 0;
}
```
### 복기
이 문제도 N과 M 9번 문제에서 조금만 변형하면 풀 수 있었다..!

<h1 align = "center">백준 5427번 불 </h1>

### [문제 링크](https://www.acmicpc.net/problem/5427 "5427번 불")
---

### 최초 코드
```cpp

//불!문제랑 비슷한 방식으로 구현 시도 BFS

#include<iostream>
#include<queue>
#include<vector>
using namespace std;
using pii = pair<int,int>;
int w, h, T,cnt=0;
char map[1001][1001];//원래string 으로 받으려 했는데 @ * 판단해서 불, 상근 큐에 추가하기 위해 char로 받음
int fvis[1001][1001] = {0,};
int svis[1001][1001] = {0,};
// 드디어 상하좌우
int dx[] = {1,0,-1,0};
int dy[] = {0,1,0,-1};
queue<pii> fq;
queue<pii> sq;

void BFS() {
	while (!fq.empty()) {
		int x = fq.front().first;
		int y = fq.front().second;
		fq.pop();
		for (auto i = 0; i < 4; ++i) {
			int nx = x + dx[i];
			int ny = y + dy[i];
			if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
			if (map[nx][ny] == '#' || fvis[nx][ny] != 0) continue;
			fvis[nx][ny] = fvis[x][y] + 1;
			fq.push({ nx,ny });
		}
	}

	while (!sq.empty()) {
		int x = sq.front().first;
		int y = sq.front().second;
		sq.pop();
		for (auto i = 0; i < 4; ++i) {
			int nx = x + dx[i];
			int ny = y + dy[i];
			if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
			if (map[nx][ny] == '#' || map[nx][ny] == '*') continue;
			if (svis[nx][ny] != 0) continue;
			if ((svis[x][y] + 1 >= fvis[nx][ny])) continue;
			svis[nx][ny] = svis[x][y] + 1;
			sq.push({ nx,ny });
		}
	}
}

int main(void) {
	cin >> T;
	while (T--) {//테스트 케이스만큼 돌리기 for문말고 while루프
		cin >> w >> h;
		for (auto i = 0; i < h; ++i) {
			for (auto j = 0; j < w; ++j) {
				cin >> map[i][j];
				if (map[i][j] == '@') {
					sq.push({ i,j });
					svis[i][j] = 1;
				}
					
				else if (map[i][j] == '*') {
					fq.push({ i,j });
					fvis[i][j] = 1;
				}
			}
		}
		BFS();
		if (cnt <= 0)
			cout << "IMPOSSIBLE" << '\n';
		cout << cnt<<'\n';
		//초기화
		memset(map, '.', sizeof(map));
		while (!fq.empty())
			fq.pop();
		while (!sq.empty())
			sq.pop();
		cnt = 0;
	}
}
```
### 복기
이 문제는 불!과 비슷해 보이지만 출구로 정해진 곳이 없어 탈출 처리를 어떻게 해야하는지 잘 안떠올랐다..
### 최종 코드
```cpp

```

<h1 align = "center">백준 1992번 쿼드트리 </h1>

### [문제 링크](https://www.acmicpc.net/problem/1992 "1992번 쿼드트리")
---

### 최초 코드   
```cpp
//종이의 개수 문제처럼 총4칸으로쪼개서 탐색하고 간단하게 묶는 알고리즘 같음 ex) 4칸 -> 16칸 이런식으로

#include<iostream>
#include<string>
using namespace std;
int N;
int map[64][64];

void func(int x, int y, int size) {
	bool check1 = true; // 1인지 판단
	bool check0 = true; // 0인지 판단
	if (size == 1) {//한변이 1인 사각형까지 오면
		cout << map[y][x];
		return;
	}
	for (auto i = y; i < y + size; ++i) {
		for (auto j = x; j < x + size; ++j) {
			if (map[i][j] == 1)
				check0 = 0;
			else
				check1 = 0;

		}
	}
	if (check0)
		cout << 0;
	else if (check1)
		cout << 1;
	else {
		cout << "(";
		func(x, y, size / 2);
		func(x + size / 2, y, size / 2);
		func(x, y + size / 2, size / 2);
		func(x + size / 2, y + size / 2, size / 2);
		cout << ")";
	}
	return;
}

int main(void) {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> N;
	string s;
	for (auto i = 0; i < N; ++i) {
		cin >> s;
		for (auto j = 0; j < N; ++j) {
			//cin >> map[i][j]; //입력이 1칸씩 나눠진게 아니고 각줄마다 이어져있는 문자열임
			map[i][j] = s[j] - '0';//문자열 각 원소를 정수로 바꿔서 저장(검색해봄)
		}
	}
	
	func(0, 0, N);

}
```
### 복기
분할정복 문제는 볼때마다 숨이 턱 막힌다.. 처음엔 예시를 보고도 이해를 못했다. 이름이 쿼드트리인것에서 아 4개로 분할하는 방식이구나 라고 생각했다.. 4개로 쪼개고 서로 다른 숫자면 또 4개로 쪼개고 반복하는 방식으로 구현하기로 했다. 구현방식은 어제풀었던 종이의 개수 문제랑 비슷하게 했다.(솔직히 한번에 맞아서 놀람..)