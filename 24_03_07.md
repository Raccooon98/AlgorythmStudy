<h1 align = "center">백준 15652번 N과 M (4)</h1>

### [문제 링크](https://www.acmicpc.net/problem/15652 "15652번 N과 M (4)")
---

### 최초 코드
```cpp
#include<iostream>
#include<vector>

using namespace std;

int N, M;
vector<int> arr;
bool vis[10];


void DFS(int num, int n) {
	if (n == M) {
		for (int i = 0; i < M; i++) {
			cout << arr[i] << ' ';
		}
		cout << '\n';
		return;
	}
	else {

		for (int i = num; i <= N; i++) {
			arr.push_back(i);
			vis[i] = 1;
			DFS(i,n + 1);
			arr.pop_back();
			vis[i] = 0;
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> N >> M;
	DFS(1,0);
}
```
### 복기
n과m 2번과 3번을 합치면 된다고 생각을했고 dfs인자에 i값을 같이 넘겨주며 문제를 해결하는 방식을 선택했다.

<h1 align = "center">백준 15653번 N과 M (5)</h1>

### [문제 링크](https://www.acmicpc.net/problem/15653 "15653번 N과 M (5)")
---

### 최초 코드
```cpp

```



<h1 align = "center">백준 1012번 유기농 배추</h1>

### [문제 링크](https://www.acmicpc.net/problem/1012 "1012번 유기농 배추")
---

### 최초 코드
```cpp
#include<iostream>
#include<queue>
using namespace std;

int dx[] = {1,0,-1,0};
int dy[] = {0,-1,0,1};

int T,N,M,K;
int map[50][50] = { 0, };
bool vis[50][50] = { 0. };
queue<pair<int, int>> q;

void BFS() {
	while (!q.empty()) {
		int x = q.front().first;
		int y = q.front().second;
		q.pop();
		vis[x][y] = 1;
		for (int i = 0; i < 4; i++) {
			int nx = x + dx[i];
			int ny = y + dy[i];
			if (nx < 0 || ny < 0 || nx >= M || ny >= N) continue;
			if (!vis[nx][ny] && map[nx][ny] == 1) {
				vis[nx][ny] = 1;
				q.push({ nx,ny });
			}
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);

	cin >> T;
	for (int i = 0; i < T; i++) {
		cin >> M >> N >> K;
		int cnt = 0;
		for (int j = 0; j < K; j++) {
			int x, y;
			cin >> x >> y;
			map[x][y] = 1;
		}
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				if (map[i][j] == 1 && !vis[i][j]) {
					q.push({ i,j });
					BFS();
					cnt++;
				}
			}
		}
		cout << cnt << '\n';
	}
}
```

### 복기
전에 풀었던 그림 문제랑 비슷한 문제라고 생각을 하고 구간의 갯수를 BFS로 구해서 풀려고 시도를 했다. 코드 방향성 자체에는 문제가 없었지만, 컴파일 에러가 났다. 한번에 여러케이스를 받는 문제라는것을 고려하지 않고 코드를 작성했었다. q,map,vis를 케이스 입력을 받기전에 초기화 해주는 작업을 하지않아서 그런것 같아서 다시 작성했다.

### 코드
```cpp
#include<iostream>
#include<queue>
using namespace std;

int dx[] = {1,0,-1,0};
int dy[] = {0,-1,0,1};

int T, N, M, K = 0;
int map[50][50] = { 0, };
bool vis[50][50] = { 0, };
queue<pair<int, int>> q;

void BFS() {
	while (!q.empty()) {
		int x = q.front().first;
		int y = q.front().second;
		q.pop();
		vis[x][y] = 1;
		for (int i = 0; i < 4; i++) {
			int nx = x + dx[i];
			int ny = y + dy[i];
			if (nx < 0 || ny < 0 || nx >= M || ny >= N) continue;
			if (!vis[nx][ny] && map[nx][ny] == 1) {
				vis[nx][ny] = 1;
				q.push({ nx,ny });
			}
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);

	cin >> T;
	for (int i = 0; i < T; i++) {
		while (!q.empty()) q.pop();
		for (int q = 0; q < N; q++) {
			for (int k = 0; k < M; k++) {
				vis[q][k] = 0;
				map[q][k] = 0;
			}
		}
		cin >> M >> N >> K;
		int cnt = 0;
		for (int j = 0; j < K; j++) {
			int x, y;
			cin >> x >> y;
			map[x][y] = 1;
		}
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				if (map[i][j] == 1 && !vis[i][j]) {
					q.push({ i,j });
					BFS();
					cnt++;
				}
			}
		}
		cout << cnt << '\n';
	}
}

```